/*
 *    Project: The EDNA Kernel
 *             http://www.edna-site.org
 *
 *    File: "$Id:$"
 *
 *    Copyright (C) 2008-2009 European Synchrotron Radiation Facility
 *                            Grenoble, France
 *
 *    Principal authors: Marie-Francoise Incardona (incardon@esrf.fr)
 *                       Olof Svensson (svensson@esrf.fr)
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU Lesser General Public License as published
 *    by the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    and the GNU Lesser General Public License  along with this program.
 *    If not, see <http://www.gnu.org/licenses/>.
 */
import xmlSchema;

extension org::eclipse::xtend::util::stdlib::globalvar;
/**
 * The name of the target file.
 */
String targetFilename () : GLOBALVAR targetFile;

String currentTime () : JAVA org.edna.datamodel.generateds.JavaExtensions.getTimestamp ();

SchemaType setSchema (SchemaType schema) : storeGlobalVar("schema", schema);
SchemaType getSchema () : getGlobalVar("schema");

/**
 * Returns true if a type has an extension element
 */
Boolean hasExtension(ComplexType ct):
	ct.complexContent.^extension != null;

/**
 * Returns the name of the extended base type
 */
String getExtension(ComplexType ct):
	ct.complexContent.^extension.base.localPart;

Boolean hasSequence(ComplexType ct):
	ct.complexContent.^extension.sequence != null;
Boolean hasSequenceShort(ComplexType ct):
	ct.sequence != null;

Boolean hasElementsInSequence(ComplexType ct):
	hasSequence(ct) && !ct.complexContent.^extension.sequence.element.isEmpty
	||
	hasSequenceShort(ct) && !ct.sequence.element.isEmpty;


List[Element] getElementsInSequence(ComplexType ct):
	ct.complexContent == null ?
		(ct.sequence!=null ? ct.sequence.element : {})
	:
	(
		ct.complexContent.^extension == null ?
		(
			{}
		)
		:
			(
			ct.complexContent.^extension.sequence == null ?
				{}
			:
			ct.complexContent.^extension.sequence.element
			)
		)
	;
/** If called for null pointer return empty list */
List[Element] getElementsInSequence(Void v): {};

String valueError(Element e):
	switch (e.type.localPart) {
		default : " ValueError('requires float (or double) -- %s' % child_.toxml())"
	};

String initAssignment(Element e):
	switch (e.type.localPart.toLowerCase()) {
		case "string" : e.name+"=''"
		case "double" : e.name+"=0.0"
		case "integer" : e.name+"=-1"
		case "boolean" : e.name+"=0"
		default : e.name+"=None"
	};

String initAssignment(ComplexType ct):
	getAllBaseDefinitions(ct, {}).getElementsInSequence().initAssignment().toString(", ");

String initValues(ComplexType ct):
	getAllBaseDefinitions(ct, {}).getElementsInSequence().name.toString(", ");

/**
 * Returns the complete hierarchy of a type.
 * @param ct A type to start with
 * @param list The list into which ct and its base types are inserted
 */
List[ComplexType] getAllBaseDefinitions(ComplexType ct, List[ComplexType] list):
	list.contains(ct) ? list : list.add(ct) ->
	ct.hasExtension() ?
		getAllBaseDefinitions(getBase(ct), list)
	:
		list
	;

ComplexType getBase(ComplexType ct):
	getComplexType(ct, getExtension(ct));

SchemaType getSchemaType(emf::EObject ctx):
	(SchemaType)ctx.eRootContainer;

ComplexType getComplexType(emf::EObject ctx, String name):
	ctx.getSchemaType().complexType.selectFirst(e|e.name == name);

/**
 * Returns true if the elements is multi-valued.
 */
Boolean isMultivalued(Element e):
	e.maxOccurs != 1;
// ----------------------------------------------------------------------------
// Compute imported type names
// ----------------------------------------------------------------------------

Set[String] allBaseTypeNames (SchemaType schema) :
	schema.complexType.select(ct|ct.hasExtension()).getBase().name.toSet();
Set[String] allReferencedTypesFromElements (SchemaType schema) :
	schema.complexType.getElementsInSequence().type.localPart;

Boolean isPrimitive (String name) :
	{"string","double","integer","boolean"}.contains(name);
Boolean isInternal (String name) : getSchema().getComplexType(name)!=null;

